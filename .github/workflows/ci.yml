name: CI

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master, develop ]

jobs:
  build-and-test:
    name: ${{ matrix.os }} - ${{ matrix.compiler }} - ${{ matrix.build_type }}
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]
        compiler: [gcc, clang]
        build_type: [Release, Debug]
        exclude:
          # macOS uses clang by default
          - os: macos-latest
            compiler: gcc
          # Only test Debug on Linux with GCC to save CI time
          - os: macos-latest
            build_type: Debug
          - os: ubuntu-latest
            compiler: clang
            build_type: Debug

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Install dependencies (Ubuntu)
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          cmake \
          libyaml-cpp-dev \
          libnetcdf-dev \
          libhdf5-dev

    - name: Install dependencies (macOS)
      if: runner.os == 'macOS'
      run: |
        brew install \
          cmake \
          yaml-cpp \
          netcdf \
          hdf5

    - name: Set up compiler (GCC)
      if: matrix.compiler == 'gcc' && runner.os == 'Linux'
      run: |
        echo "CC=gcc" >> $GITHUB_ENV
        echo "CXX=g++" >> $GITHUB_ENV

    - name: Set up compiler (Clang)
      if: matrix.compiler == 'clang'
      run: |
        echo "CC=clang" >> $GITHUB_ENV
        echo "CXX=clang++" >> $GITHUB_ENV

    - name: Configure CMake (Basic)
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} \
          -DNDARRAY_BUILD_TESTS=ON \
          -DNDARRAY_BUILD_EXAMPLES=OFF \
          -DNDARRAY_USE_NETCDF=AUTO \
          -DNDARRAY_USE_HDF5=AUTO \
          -DNDARRAY_USE_YAML=AUTO

    - name: Build
      run: cmake --build build -j$(nproc 2>/dev/null || sysctl -n hw.ncpu)

    - name: Run tests
      working-directory: build
      run: ctest --output-on-failure

  build-minimal:
    name: Minimal build (no dependencies)
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Install minimal dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake

    - name: Configure CMake (Minimal)
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Release \
          -DNDARRAY_BUILD_TESTS=ON \
          -DNDARRAY_BUILD_EXAMPLES=OFF \
          -DNDARRAY_USE_NETCDF=OFF \
          -DNDARRAY_USE_HDF5=OFF \
          -DNDARRAY_USE_ADIOS2=OFF \
          -DNDARRAY_USE_MPI=OFF \
          -DNDARRAY_USE_VTK=OFF \
          -DNDARRAY_USE_YAML=OFF

    - name: Build
      run: cmake --build build -j$(nproc)

    - name: Run tests
      working-directory: build
      run: ctest --output-on-failure

  # code-style:
  #   name: Code style check
  #   runs-on: ubuntu-latest
  #
  #   steps:
  #   - name: Checkout code
  #     uses: actions/checkout@v3
  #
  #   - name: Check for common issues
  #     run: |
  #       # Check for trailing whitespace in include and test directories
  #       if git grep -I -n '[[:blank:]]$' -- 'include/**/*.cpp' 'include/**/*.hh' 'include/**/*.h' 'tests/*.cpp' 'tests/*.hh' 'tests/*.h' 'src/*.cpp' 2>/dev/null; then
  #         echo "Found trailing whitespace in source files"
  #         exit 1
  #       fi
  #
  #       # Check for tabs (prefer spaces)
  #       if git grep -I -n $'\t' -- 'include/**/*.cpp' 'include/**/*.hh' 'include/**/*.h' 'tests/*.cpp' 'tests/*.hh' 'tests/*.h' 'src/*.cpp' 2>/dev/null; then
  #         echo "Found tabs in source files, prefer spaces"
  #         exit 1
  #       fi
  #
  #       echo "Code style checks passed"

  build-cuda:
    name: CUDA build (Ubuntu)
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Install GCC-12 (CUDA 12.0 compatible)
      run: |
        sudo apt-get update
        sudo apt-get install -y gcc-12 g++-12
        sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-12 100
        sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-12 100

    - name: Cache CUDA
      id: cache-cuda
      uses: actions/cache@v3
      with:
        path: ~/cuda-12.0
        key: cuda-12.0-ubuntu2204-v1

    - name: Install CUDA Toolkit
      if: steps.cache-cuda.outputs.cache-hit != 'true'
      run: |
        wget https://developer.download.nvidia.com/compute/cuda/12.0.0/local_installers/cuda_12.0.0_525.60.13_linux.run
        # Install to home directory to avoid sudo/permission issues with caching
        mkdir -p ~/cuda-12.0
        sh cuda_12.0.0_525.60.13_linux.run --silent --toolkit --override --toolkitpath=$HOME/cuda-12.0

    - name: Set CUDA Path
      run: |
        echo "$HOME/cuda-12.0/bin" >> $GITHUB_PATH
        echo "LD_LIBRARY_PATH=$HOME/cuda-12.0/lib64:$LD_LIBRARY_PATH" >> $GITHUB_ENV
        echo "CUDA_PATH=$HOME/cuda-12.0" >> $GITHUB_ENV
        echo "CUDA_TOOLKIT_ROOT_DIR=$HOME/cuda-12.0" >> $GITHUB_ENV

    - name: Set GCC-12 for NVCC
      run: |
        echo "CC=gcc-12" >> $GITHUB_ENV
        echo "CXX=g++-12" >> $GITHUB_ENV

    - name: Configure CMake (CUDA)
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Release \
          -DNDARRAY_BUILD_TESTS=ON \
          -DNDARRAY_BUILD_EXAMPLES=OFF \
          -DNDARRAY_USE_CUDA=ON \
          -DNDARRAY_USE_MPI=OFF \
          -DNDARRAY_USE_YAML=OFF \
          -DCMAKE_C_COMPILER=gcc-12 \
          -DCMAKE_CXX_COMPILER=g++-12 \
          -DCMAKE_CUDA_COMPILER=$HOME/cuda-12.0/bin/nvcc \
          -DCMAKE_CUDA_HOST_COMPILER=g++-12

    - name: Build
      run: cmake --build build -j$(nproc)

  build-mpi:
    name: MPI build (Ubuntu)
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Install dependencies
      run: |
        sudo apt-get update
        # Explicitly remove OpenMPI to avoid mpirun conflicts with MPICH
        sudo apt-get remove -y openmpi-bin libopenmpi-dev || true
        sudo apt-get install -y \
          cmake \
          libyaml-cpp-dev \
          libnetcdf-dev \
          libhdf5-dev \
          libhdf5-mpich-dev \
          mpich \
          libmpich-dev

    - name: Configure CMake (MPI)
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Release \
          -DNDARRAY_BUILD_TESTS=ON \
          -DNDARRAY_BUILD_EXAMPLES=OFF \
          -DNDARRAY_USE_MPI=ON \
          -DNDARRAY_USE_NETCDF=AUTO \
          -DNDARRAY_USE_HDF5=AUTO \
          -DNDARRAY_USE_YAML=AUTO

    - name: Build
      run: cmake --build build -j$(nproc)

    - name: Run serial tests
      working-directory: build
      run: ctest --output-on-failure -E "distributed|ghost_exchange|mpi"

    - name: Check if MPI tests exist
      id: check_mpi_tests
      working-directory: build
      run: |
        if [ -f bin/test_distributed_ndarray ]; then
          echo "has_mpi_tests=true" >> $GITHUB_OUTPUT
        else
          echo "has_mpi_tests=false" >> $GITHUB_OUTPUT
        fi

    - name: Run MPI tests
      if: steps.check_mpi_tests.outputs.has_mpi_tests == 'true'
      working-directory: build
      run: |
        echo "Running MPI tests with MPICH..."

        # Prefer MPICH-specific mpirun to avoid OpenMPI conflicts
        if [ -x /usr/bin/mpirun.mpich ]; then
          MPIRUN=/usr/bin/mpirun.mpich
        elif [ -x /usr/bin/mpiexec.mpich ]; then
          MPIRUN=/usr/bin/mpiexec.mpich
        else
          MPIRUN=mpirun
        fi
        echo "Using: $MPIRUN"

        # Run distributed tests with different rank counts
        for np in 2 4; do
          echo "Testing with $np ranks..."
          $MPIRUN -np $np bin/test_distributed_ndarray || {
            echo "MPI test with $np ranks failed"
            exit 1
          }
        done
        echo "All MPI tests passed"

  build-storage-backends:
    name: Storage backends (Eigen + xtensor)
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          cmake \
          libyaml-cpp-dev \
          libeigen3-dev

    - name: Install xtensor (header-only library)
      run: |
        # Install xtl 0.7.x (compatible with C++17)
        echo "Installing xtl 0.7.5..."
        git clone --depth 1 --branch 0.7.5 https://github.com/xtensor-stack/xtl.git
        cd xtl
        mkdir build && cd build
        cmake .. -DCMAKE_INSTALL_PREFIX=/usr/local
        sudo make install
        cd ../..

        # Verify xtl installation
        if [ -d "/usr/local/include/xtl" ]; then
          echo "✓ xtl installed successfully to /usr/local/include/xtl"
          ls /usr/local/include/xtl/*.hpp | head -5
        else
          echo "✗ xtl installation failed!"
          exit 1
        fi

        # Install xtensor 0.24.x (compatible with C++17)
        echo "Installing xtensor 0.24.7..."
        git clone --depth 1 --branch 0.24.7 https://github.com/xtensor-stack/xtensor.git
        cd xtensor
        mkdir build && cd build
        cmake .. -DCMAKE_INSTALL_PREFIX=/usr/local
        sudo make install
        cd ../..

        # Verify xtensor installation
        if [ -d "/usr/local/include/xtensor" ]; then
          echo "✓ xtensor installed successfully to /usr/local/include/xtensor"
          ls /usr/local/include/xtensor/*.hpp | head -5
          ls /usr/local/include/xtensor/xarray.hpp || echo "✗ xarray.hpp not found!"
        else
          echo "✗ xtensor installation failed!"
          exit 1
        fi

    - name: Configure CMake (Storage backends)
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Release \
          -DCMAKE_PREFIX_PATH=/usr/local \
          -DNDARRAY_BUILD_TESTS=ON \
          -DNDARRAY_BUILD_EXAMPLES=OFF \
          -DNDARRAY_USE_EIGEN=AUTO \
          -DNDARRAY_USE_XTENSOR=AUTO \
          -DNDARRAY_USE_YAML=AUTO

    - name: Build
      run: cmake --build build -j$(nproc)

    - name: Run tests
      working-directory: build
      run: ctest --output-on-failure

  build-sanitizers:
    name: Build with sanitizers (Ubuntu + Clang)
    runs-on: ubuntu-latest
    if: false  # Disabled: ASAN can be flaky, not critical for every commit

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          cmake \
          clang \
          libyaml-cpp-dev

    - name: Configure CMake (AddressSanitizer)
      run: |
        export CC=clang
        export CXX=clang++
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Debug \
          -DNDARRAY_BUILD_TESTS=ON \
          -DNDARRAY_BUILD_EXAMPLES=OFF \
          -DNDARRAY_USE_YAML=AUTO \
          -DCMAKE_CXX_FLAGS="-fsanitize=address -fno-omit-frame-pointer -g"

    - name: Build
      run: cmake --build build -j$(nproc)

    - name: Run tests with AddressSanitizer
      working-directory: build
      run: ASAN_OPTIONS=detect_leaks=1 ctest --output-on-failure

  build-pnetcdf:
    name: PNetCDF (Parallel NetCDF)
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          cmake \
          mpich \
          libmpich-dev \
          m4 \
          automake \
          autoconf \
          libtool

    - name: Cache PNetCDF
      id: cache-pnetcdf
      uses: actions/cache@v3
      with:
        path: ~/pnetcdf
        key: pnetcdf-1.12.3-${{ runner.os }}

    - name: Build and install PNetCDF
      if: steps.cache-pnetcdf.outputs.cache-hit != 'true'
      run: |
        # Download PNetCDF
        wget https://parallel-netcdf.github.io/Release/pnetcdf-1.12.3.tar.gz
        tar -xzf pnetcdf-1.12.3.tar.gz
        cd pnetcdf-1.12.3

        # Configure and build (install to ~/pnetcdf for caching)
        ./configure --prefix=$HOME/pnetcdf --enable-shared
        make -j$(nproc)
        make install
        cd ..

    - name: Set up PNetCDF environment
      run: |
        echo "$HOME/pnetcdf/bin" >> $GITHUB_PATH
        echo "LD_LIBRARY_PATH=$HOME/pnetcdf/lib:$LD_LIBRARY_PATH" >> $GITHUB_ENV

    - name: Configure CMake (PNetCDF)
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Release \
          -DCMAKE_PREFIX_PATH=$HOME/pnetcdf \
          -DNDARRAY_BUILD_TESTS=ON \
          -DNDARRAY_BUILD_EXAMPLES=OFF \
          -DNDARRAY_USE_MPI=ON \
          -DNDARRAY_USE_PNETCDF=ON

    - name: Build
      run: cmake --build build -j$(nproc)

    - name: Run tests
      working-directory: build
      run: ctest --output-on-failure -E "distributed|ghost"

  build-adios2:
    name: ADIOS2 (BP file format)
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Install dependencies
      run: |
        sudo apt-get update
        # Explicitly remove OpenMPI to avoid mpirun conflicts with MPICH
        sudo apt-get remove -y openmpi-bin libopenmpi-dev || true
        sudo apt-get install -y \
          cmake \
          mpich \
          libmpich-dev \
          libyaml-cpp-dev \
          libhdf5-dev \
          libblosc-dev

    - name: Cache ADIOS2
      id: cache-adios2
      uses: actions/cache@v3
      with:
        path: ~/adios2
        key: adios2-2.10.1-mpich-compilers-${{ runner.os }}

    - name: Build and install ADIOS2
      if: steps.cache-adios2.outputs.cache-hit != 'true'
      run: |
        # Download ADIOS2
        wget https://github.com/ornladios/ADIOS2/archive/refs/tags/v2.10.1.tar.gz
        tar -xzf v2.10.1.tar.gz
        cd ADIOS2-2.10.1

        # Configure and build (install to ~/adios2 for caching)
        # Explicitly specify MPICH compilers to avoid MPI library mismatch
        mkdir build && cd build
        cmake .. \
          -DCMAKE_INSTALL_PREFIX=$HOME/adios2 \
          -DCMAKE_BUILD_TYPE=Release \
          -DCMAKE_C_COMPILER=mpicc.mpich \
          -DCMAKE_CXX_COMPILER=mpicxx.mpich \
          -DBUILD_SHARED_LIBS=ON \
          -DADIOS2_USE_MPI=ON \
          -DADIOS2_USE_HDF5=ON \
          -DADIOS2_USE_Python=OFF \
          -DADIOS2_USE_Fortran=OFF \
          -DBUILD_TESTING=OFF \
          -DADIOS2_BUILD_EXAMPLES=OFF

        make -j$(nproc)
        make install
        cd ../..

    - name: Set up ADIOS2 environment
      run: |
        echo "$HOME/adios2/bin" >> $GITHUB_PATH
        echo "LD_LIBRARY_PATH=$HOME/adios2/lib:$LD_LIBRARY_PATH" >> $GITHUB_ENV

    - name: Configure CMake (ADIOS2)
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Release \
          -DCMAKE_C_COMPILER=mpicc.mpich \
          -DCMAKE_CXX_COMPILER=mpicxx.mpich \
          -DCMAKE_PREFIX_PATH=$HOME/adios2 \
          -DNDARRAY_BUILD_TESTS=ON \
          -DNDARRAY_BUILD_EXAMPLES=OFF \
          -DNDARRAY_USE_ADIOS2=ON \
          -DNDARRAY_USE_YAML=ON \
          -DNDARRAY_USE_MPI=ON

    - name: Build
      run: cmake --build build -j$(nproc)

    - name: Run serial tests
      working-directory: build
      run: ctest --output-on-failure -R "adios2"

    - name: Run parallel ADIOS2 tests
      working-directory: build
      run: |
        echo "Running parallel ADIOS2 tests with MPI..."

        # Diagnose MPI environment
        echo "=== MPI Environment Diagnostics ==="
        which mpirun || echo "mpirun not found"
        which mpirun.mpich || echo "mpirun.mpich not found"
        which mpiexec.mpich || echo "mpiexec.mpich not found"

        # Check for OpenMPI (should not be present)
        if which mpirun.openmpi 2>/dev/null; then
          echo "WARNING: OpenMPI found - this may cause conflicts with MPICH"
        fi

        # Use mpiexec.mpich (more reliable than mpirun.mpich on CI)
        MPIRUN="mpiexec.mpich"
        echo "Using: $MPIRUN"
        $MPIRUN --version || true

        # Test basic MPI functionality with different launchers
        echo "=== Testing basic MPI spawn ==="
        cat > /tmp/mpi_test.c << 'EOFTEST'
        #include <mpi.h>
        #include <stdio.h>
        int main(int argc, char** argv) {
            MPI_Init(&argc, &argv);
            int rank, size;
            MPI_Comm_rank(MPI_COMM_WORLD, &rank);
            MPI_Comm_size(MPI_COMM_WORLD, &size);
            printf("Rank %d of %d\n", rank, size);
            fflush(stdout);
            MPI_Finalize();
            return 0;
        }
        EOFTEST
        mpicc.mpich -o /tmp/mpi_test /tmp/mpi_test.c

        echo "Testing with default launcher:"
        $MPIRUN -np 2 /tmp/mpi_test || echo "Default launcher failed"

        echo "Testing with fork launcher:"
        $MPIRUN -launcher fork -np 2 /tmp/mpi_test || echo "Fork launcher failed"

        # Use whichever works
        if $MPIRUN -launcher fork -np 2 /tmp/mpi_test 2>&1 | grep -q "Rank 1 of 2"; then
          echo "Fork launcher works - using it for tests"
          MPIRUN="mpiexec.mpich -launcher fork"
        else
          echo "Using default launcher"
          MPIRUN="mpiexec.mpich"
        fi

        echo "=== Running ADIOS2 parallel tests ==="
        if [ -f bin/test_adios2_parallel ]; then
          for np in 2 4; do
            echo "Testing test_adios2_parallel with $np MPI ranks..."
            $MPIRUN -np $np bin/test_adios2_parallel || {
              echo "Parallel ADIOS2 test with $np ranks failed"
              exit 1
            }
          done
          echo "All parallel ADIOS2 tests passed"
        else
          echo "test_adios2_parallel not built - skipping parallel tests"
        fi

  build-png:
    name: PNG support (libpng)
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          cmake \
          libpng-dev

    - name: Configure CMake (PNG)
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Release \
          -DNDARRAY_BUILD_TESTS=ON \
          -DNDARRAY_BUILD_EXAMPLES=OFF \
          -DNDARRAY_USE_PNG=ON

    - name: Build
      run: cmake --build build -j$(nproc)

    - name: Run tests
      working-directory: build
      run: ctest --output-on-failure

  build-all-formats:
    name: All I/O formats (NetCDF+HDF5+YAML+PNG)
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          cmake \
          libyaml-cpp-dev \
          libnetcdf-dev \
          libhdf5-dev \
          libpng-dev

    - name: Configure CMake (All formats)
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Release \
          -DNDARRAY_BUILD_TESTS=ON \
          -DNDARRAY_BUILD_EXAMPLES=OFF \
          -DNDARRAY_USE_NETCDF=ON \
          -DNDARRAY_USE_HDF5=ON \
          -DNDARRAY_USE_YAML=ON \
          -DNDARRAY_USE_PNG=ON

    - name: Build
      run: cmake --build build -j$(nproc)

    - name: Run tests
      working-directory: build
      run: ctest --output-on-failure

  build-vtk:
    name: VTK support
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Install minimal dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake

    - name: Cache VTK
      id: cache-vtk
      uses: actions/cache@v3
      with:
        path: ~/vtk
        key: vtk-9.6.0-minimal-v2-${{ runner.os }}

    - name: Build and install VTK from source
      if: steps.cache-vtk.outputs.cache-hit != 'true'
      run: |
        # Download VTK 9.6.0
        wget https://www.vtk.org/files/release/9.6/VTK-9.6.0.tar.gz
        tar -xzf VTK-9.6.0.tar.gz
        cd VTK-9.6.0

        # Configure minimal VTK build (no Qt, no Python, no MPI, no OpenGL2)
        mkdir build && cd build
        cmake .. \
          -DCMAKE_BUILD_TYPE=Release \
          -DCMAKE_INSTALL_PREFIX=$HOME/vtk \
          -DBUILD_SHARED_LIBS=ON \
          -DBUILD_TESTING=OFF \
          -DVTK_GROUP_ENABLE_Rendering=NO \
          -DVTK_GROUP_ENABLE_StandAlone=WANT \
          -DVTK_MODULE_ENABLE_VTK_CommonCore=YES \
          -DVTK_MODULE_ENABLE_VTK_CommonDataModel=YES \
          -DVTK_MODULE_ENABLE_VTK_IOXML=YES \
          -DVTK_MODULE_ENABLE_VTK_IOLegacy=YES \
          -DVTK_MODULE_ENABLE_VTK_FiltersCore=YES \
          -DVTK_WRAP_PYTHON=OFF \
          -DVTK_USE_MPI=OFF

        # Build and install
        make -j$(nproc)
        make install
        cd ../..

    - name: Set up VTK environment
      run: |
        echo "VTK_DIR=$HOME/vtk/lib/cmake/vtk-9.6" >> $GITHUB_ENV
        echo "LD_LIBRARY_PATH=$HOME/vtk/lib:$LD_LIBRARY_PATH" >> $GITHUB_ENV

    - name: Clean build directory
      run: rm -rf build

    - name: Configure CMake (VTK)
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Release \
          -DCMAKE_PREFIX_PATH=$HOME/vtk \
          -DNDARRAY_BUILD_TESTS=ON \
          -DNDARRAY_BUILD_EXAMPLES=OFF \
          -DNDARRAY_USE_VTK=ON \
          -DNDARRAY_USE_MPI=OFF

    - name: Build
      run: cmake --build build -j$(nproc)

    - name: Run tests
      working-directory: build
      run: ctest --output-on-failure

  build-cpp-standards:
    name: C++ Standard ${{ matrix.std }}
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        std: [17, 20]

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          cmake \
          g++-11 \
          libyaml-cpp-dev \
          libnetcdf-dev \
          libhdf5-dev

    - name: Set up compiler
      run: |
        echo "CC=gcc-11" >> $GITHUB_ENV
        echo "CXX=g++-11" >> $GITHUB_ENV

    - name: Configure CMake (C++${{ matrix.std }})
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Release \
          -DCMAKE_CXX_STANDARD=${{ matrix.std }} \
          -DNDARRAY_BUILD_TESTS=ON \
          -DNDARRAY_BUILD_EXAMPLES=OFF \
          -DNDARRAY_USE_NETCDF=AUTO \
          -DNDARRAY_USE_HDF5=AUTO \
          -DNDARRAY_USE_YAML=AUTO

    - name: Build
      run: cmake --build build -j$(nproc)

    - name: Run tests
      working-directory: build
      run: ctest --output-on-failure

  documentation:
    name: Check documentation
    runs-on: ubuntu-latest
    if: false  # Disabled: too basic, just checks files exist

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Verify documentation files exist
      run: |
        test -f README.md || (echo "README.md missing" && exit 1)
        test -f CHANGELOG.md || (echo "CHANGELOG.md missing" && exit 1)
        test -f CONTRIBUTING.md || (echo "CONTRIBUTING.md missing" && exit 1)
        test -f LICENSE || (echo "LICENSE missing" && exit 1)
        echo "All required documentation files present"

    - name: Check for broken links in README
      run: |
        # Basic check for common markdown issues
        grep -n '](http' README.md || echo "No external links found"
        grep -n ']\[' README.md && (echo "Found undefined link references" && exit 1) || true
        echo "Documentation checks passed"

  code-coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    if: false

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          cmake \
          g++ \
          gcovr \
          lcov \
          libyaml-cpp-dev \
          libnetcdf-dev \
          libhdf5-dev \
          libpng-dev

    - name: Configure CMake with coverage flags
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_CXX_FLAGS="--coverage -fprofile-arcs -ftest-coverage" \
          -DCMAKE_C_FLAGS="--coverage -fprofile-arcs -ftest-coverage" \
          -DCMAKE_EXE_LINKER_FLAGS="--coverage" \
          -DNDARRAY_BUILD_TESTS=ON \
          -DNDARRAY_BUILD_EXAMPLES=OFF \
          -DNDARRAY_USE_NETCDF=TRUE \
          -DNDARRAY_USE_HDF5=TRUE \
          -DNDARRAY_USE_YAML=TRUE \
          -DNDARRAY_USE_PNG=TRUE

    - name: Build with coverage
      run: cmake --build build -j$(nproc)

    - name: Run tests
      working-directory: build
      run: ctest --output-on-failure || true

    - name: Generate coverage report (gcovr)
      working-directory: build
      continue-on-error: true
      run: |
        gcovr -r .. --print-summary --xml coverage.xml --html coverage.html --html-details \
          --exclude '../tests/.*' \
          --exclude '.*/build/.*' \
          --exclude '.*/CMakeFiles/.*' || echo "gcovr failed, continuing..."

    - name: Generate coverage report (lcov)
      working-directory: build
      continue-on-error: true
      run: |
        lcov --capture --directory . --output-file coverage.info --rc lcov_branch_coverage=1 || echo "lcov capture failed"
        lcov --remove coverage.info \
          '/usr/*' \
          '*/tests/*' \
          '*/build/*' \
          '*/CMakeFiles/*' \
          --output-file coverage_filtered.info --rc lcov_branch_coverage=1 || echo "lcov remove failed"
        lcov --list coverage_filtered.info --rc lcov_branch_coverage=1 || echo "lcov list failed"

    - name: Generate HTML report
      working-directory: build
      run: |
        genhtml coverage_filtered.info --output-directory coverage_html --rc lcov_branch_coverage=1
        echo "Coverage report generated in build/coverage_html/index.html"

    - name: Display coverage summary
      working-directory: build
      run: |
        echo "=== Coverage Summary ==="
        lcov --summary coverage_filtered.info --rc lcov_branch_coverage=1

    - name: Upload coverage artifact
      uses: actions/upload-artifact@v3
      with:
        name: coverage-report
        path: |
          build/coverage.html
          build/coverage_html/
        retention-days: 30

    - name: Check coverage threshold
      working-directory: build
      continue-on-error: true
      run: |
        if [ -f coverage_filtered.info ]; then
          COVERAGE=$(lcov --summary coverage_filtered.info --rc lcov_branch_coverage=1 2>&1 | grep "lines" | awk '{print $2}' | sed 's/%//' || echo "0")
          echo "Line coverage: ${COVERAGE}%"
          if (( $(echo "$COVERAGE < 60.0" | bc -l 2>/dev/null || echo 1) )); then
            echo "Warning: Coverage is below 60%"
          else
            echo "Coverage threshold met (>= 60%)"
          fi
        else
          echo "No coverage data available"
        fi
